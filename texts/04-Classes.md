## Классы

**Класс** - основа объектно-ориентированного программирования. Классы описывают внутреннюю структуру и поведение объектов, с помощью которых описывается решение задачи. Использовать ООП - это значит разработать систему классов, описать их взаимодействие и тем самым получить запись решения.

С точки зрения программиста, классы содержат данные (поля) и функции (методы).

### Анатомия класса

Содержимое класса обычно находится в специальных разделах, разграничивающих доступ. Существуют три ключевых слова (**private** - закрытый, **protected** - защищенный, **public** - открытый), которые используются для обозначения начала раздела. Данные класса стараются закрыть, спрятать от пользователей класса, а доступ к ним осуществляется через открытые методы.


Обычно используют заголовочные файлы, в которые помещают описание класса. Рассмотрим пример класса **Counter** (счетчик).

`Counter.h`

```c++
#ifndef _COUNTER_H
#define _COUNTER_H_

typedef unsigned int count_t;

class Counter
{
private:
  count_t count;
public:
  void reset();
  void inc();
  count_t get() const;
};
#endif
```

Реализация методов класса обычно размещается в .cpp файле:

`Counter.cpp`

```c++
#include "Counter.h"

void Counter::reset()
{
   count=0;
}
void Counter::inc()
{
   count++;
}
count_t Counter::get() const
{
   return count;
}
```

В проекте, где необходио использвать класс **Counter**, выполняется включение заголовочного файла в те модули, которые используют класс, а далее выполняется компоновка с откомпилированной версией `Counter.cpp`.

Можно использовать  следующую команду при работе с `g++` ( предполагается, что в **main** основная программа):

```
g++ -o app main.cpp Counter.cpp
```

Основное преимущество при использовании классов заключается в возможности отдельно разрабатывать состав и поведение сложных объектов, не изменяя сценарий их использования.

### Создание экземпляров класса

Экземпляры класса (объекты) создаются различными способами. Если мы хотим создать их в стеке, подобно обычным автоматическим переменным, то пишем так:

```c++
int main()
{
   Counter pass;
   ...
}
```

Также создаются и массивы объектов:

```c++
int main()
{
   Counter pass[10];
   ...
}
```

Наиболее популярный способ - создание динамических объектов (в куче):

```c++
int main()
{
   Counter *pass=new Counter;     // одиночный объект
   Counter *zoo=new Counter[10];  // массив из объектов
   ...
}
```
При создании динамических объектов предполагается вызов **delete** для освобождения динамической памяти:

```c++
   ...
   delete pass;
   delete[] zoo;
   ...

```

### Специальные члены класса

К специальным членам класса можно отнести

- конструкторы
- деструкторы
- указатель **this**

**Конструктор** - это метод класса, который вызывается при создании объекта, сразу же после выделения объекту памяти. Основное назначение этого метода - провести инициализацию полей класса и выделить дополнительную память под внутренние переменные или массивы.

Конструкторы бывают:

- **По-умолчанию** - это конструктор без параметров в случае описания и неявный конструктор, назначаемый самой программой в случае отсутствия явного описания (как в класса **Counter** выше)
- **Обычный** - конструктор с параметрами.
- **Копирующий** - создающий копию имеющегося объекта.
- **Перемещающий** - выполняющий действия по перемещению данных их одного объекта в другой (С++11).

В стандарте С++11 появилась возможность инициализировать поля класса непосредственно при объявлении:

```c++
class Counter
{
private:
  count_t count=0;
public:
  ...
};
```

При наличии нескольких полей, при инициализации можно ссылаться на значенения ранее инициализированных полей:

```c++
class A
{
private:
  count_t count1=0;
  count_t count2=count_1+1;
  count_t count3=count_2+1;
public:
  ...
};
```

При этом сохраняется возможность иницализации через конструкторы, что будет иметь больший приоритет при наличии двух способов.

Рассмотрим различные виды конструкторов на примере строкового класса:

```c++
class String
{
private:
	char *buf;  // поле для хранения символьного массива
	size_t len;     // длина строки
public:
   String(size_t);   // конструктор с параметром числового типа
   String(const char* =nullptr);// конструктор с параметром-указателем
   String(const String&); // конструктор копирования
   String(String&&);  // конструктор перемещения
	...
};
```

Конструктором по-умолчанию здесь выступает второй конструктор, поскольку у указателя есть значение **nullptr**, присваиваемое по-умолчанию.

Реализация конструкторов:


```c++
String::String(size_t len) 
{
	this->len = len;
	buf = new char[len];
	*buf = 0;
}

String::String(const char * str) :String(strlen(str) + 1)
{
	strcpy(buf, str);
}
String::String(const String& s) : String(s.len)
{
	strcpy(buf, s.buf);
}
String::String(String && s)
{
	buf = s.buf;
	len = s.len;
	s.buf = nullptr;
	s.len = 0;
}
```

При реализации конструкторов 2 и 3 использовалась возможность, введенная в стандарте С++11, а именно: **явный вызов конструкторов**, то есть операция выделения памяти находится в первом конструкторе и мы вызываем его явно из других.

Перемещающий конструктор выполняет перенос данных без копирование, то есть захватывает значение указателя, обнуляя оригинал. 

**Деструктор** класса - это функция, которая вызывается автоматически при разрушении объекта (или окончания времени жизни). Самое распространенное назначение этого метода - освобождение выделенной в конструкторе динамической памяти:

```c++
class String
{
...
public:
...
   ~String();
...
};

String::~String()
{
   delete[]buf;
}
```

Указатель **this** позволяет объекту узнать свой адрес или сослаться на члены класса в случае неоднозначности имен-параметров:

```c++
String(int len)
{
   this->len=len; // уточняем имена
}
...
String& get()
{
   return *this; // возвращаем ссылку на себя
}   
```

Еще одной интересной возможностью стандарта С++11 является явное указание того, что тело стандартного метода должно быть выбрано по-умолчанию. Для этого существует ключевое слово **default**:

```c++
class Foo
{
public:
    Foo() = default;
    Foo(int x) {/* ... */}
};
```

Спецификатор **default** может применяться только к специальным функциям-членам:

* конструктор по-умолчанию;
* конструктор копий;
* конструктор перемещения;
* оператор присваивания;
* оператор перемещения;
* деструктор.

Спецификатор **delete** помечает те методы, работать с которыми нельзя. Раньше приходилось объявлять такие конструкторы в приватной области класса.

```c++
class Foo
{
public:
    Foo() = default;
    Foo(const Foo&) = delete;
    void bar(int) = delete;
    void bar(double) {}
};
// ...
Foo obj;
obj.bar(5);     // ошибка!
obj.bar(5.42);  // ok
```

### Пример использования класса *String*

```c++
int main()
{
	String a("abc");
	String b{ "qwerty" };

	String t{ move(a) };
	a = move(b);
	b = move(t);
	...
```

В приведенном примере мы создаем два объекта типа **String** и присваиваем им начальные значения в виде строковых констант. Основным отличием является то, что **a** создается традиционным способом, а **b** использует список инициализации {}. В следующих трех строчках реализуется алгоритм обмена содержимым между **a** и **b**. Для задействования конструктора перемещения мы используем функцию **move** из стандартной библиотеки С++.

### Модификатор конструктора *explicit*

В новых стандартах появилось ключевое слово **explicit** для использования с конструкторами. 

Конструктор с таким модификатором запрещает создание объекта с преобразованием типа:

```c++
class String
{
   ...
public:
   explicit String(const char*);   // конструктор с параметром числового типа
	...
};

int main()
{
	String a("abc");        // разрешено
	String b{ "qwerty" };   // разрешено
	String c={"123"};       // запрещено!
	String d="zxc";         // запрещено!
	...
```

Все дело в том, что в последних двух примерах выполняется неявное преобразование строки в объект **String**, что было бы возможным при отсутствии **explicit**. Данный модификатор придумали, чтобы исключить такие неявные преобразования.

Вот еще пример с сайта [stack overflow](https://ru.stackoverflow.com/questions/547797/explicit-практическое-применение):

```cpp
class Foo 
{
public:
    operator int() const 
    { 
        return 42; 
    }
};

class Bar 
{ 
public:
    Bar(Foo) 
    {

    } 
};

void baz(Bar)
{

}

void baz(int)
{

}

int main()
{
    Foo x;
    baz(x);
}
```
Вызов функции baz здесь приведет к неопределенности для компилятора, т.к. он попадает под оба варианта `baz(int)` и `baz(Bar)`. Добавление **explicit** к конструктору **Bar** даст компилятору однозначное указание к выбору функции.

### Инициализация в конструкторе (константы, ссылки)

Рассмотрим пример класса, в котором необходимо инициализировать константное поле:

```cpp
class Mathem
{
private:
    const double pi;
public:
    Mathem(const double _pi) {
        pi=_pi;
    }
};

int main()
{
    Mathem m{3.14159};
    return 0;
}
```

При компиляции возникает ошибка:

>  error: constructor for 'Mathem' must explicitly initialize
      the const member 'pi'

Для инициализации константных и ссылочных полей используют другой синтаксис:

```cpp
class Mathem
{
private:
    const double pi;
public:
    Mathem(const double _pi) : pi{_pi}
    {}
};

int main()
{
    Mathem m{3.14159};
    return 0;
}
```

или еще проще:

```cpp
class Mathem
{
private:
    const double pi=3.14159;
public:
};

int main()
{
    Mathem m;
    return 0;
}
```

Пример с ссылками:

```cpp
class A
{
};

class B
{
private:
   const A& a;
public:
    B(const A& _a):a{_a}{}
   
};

int main()
{
    A a1;
    B b1{a1};
    return 0;
}
```

### Управление доступом к классу

Главная забота класса - скрыть как можно больше информации. Существует 4 вида пользователей класса:

1. сам класс;
1. обычные пользователи (другие классы);
1. производные классы;
1. дружественные классы;

Каждый пользователь обладает привилегиями доступа к членам класса.

Рассмотрим правила, определяющие доступ к элементам класса

- Сам класс имеет полный доступ ко всем своим элементам;
- Обычные пользователи (другие классы) имеют полный доступ только к открытому (**public**) разделу;
- Производные классы имеют доступ к **public** -разделу и к разделу **protected**;
- Дружественные классы и функции имеют полный доступ ко всем разделам;

Разумеется, для внешних пользователей класса, приватные члены доступны через интерфейсные public-методы.

### Дружественность

Дружественный класс имеет доступ как к общедоступным, так и к закрытым членам другого класса. С ключевым словом **friend** может быть объявлен как целый класс, так и отдельная функция.

```cpp
class MyClass1 
{
   friend MyClass2; 
   ...
};

class MyClass2 
{
  ...
};
```

Класс **MyClass2** теперь имеет право обращаться к закрытым и защищенным членам класса **MyClass1**. Обратное, однако, не верно до тех пор, пока в описание класса **MyClass2** мы не поместим строку friend **MyClass1**. Таким образом, дружественность не взаимна.

Отношение дружественности не наследуется!

Пример:

```cpp
class Vector 
{
   float V[4];
   //...
   friend Vector operator*(const Matrix&, const Vector&);
};
class Matrix 
{
   Vector M[4];
   //...
   friend Vector operator*(const Matrix&, const Vector&);
};

friend Vector operator*(const Matrix& rm, const Vector& rv) 
{
   Vector tmp;
   //...
   tmp.V[i] += rm.M[i].V[j] * rv.V[j];
}
```

### Полное и неполное объявление класса

Неполное объявление используется для ссылки на класс, который еще не совсем определен, например, когда он находится в другом файле или расположен ниже по тексту в этом же файле.

Нельзя создать экземпляр неполно объявленного класса.

```cpp
// ПРЕДВАРИТЕЛЬНОЕ ОБЪЯВЛЕНИЕ
class MyClass;

MyClass *mc; // для этого мы добавили неполное объявление

// ПОЛНОЕ ОПИСАНИЕ
class MyClass
{
   ......
};
```

### Static-члены класса

В классе мы можем использовать поля и методы c ключевым словом **static**. Особенность их в том, что они принадлежат именно классам, а не конкретным экземплярам, то есть не тиражируются при создании объектов. Статические переменные должны инициализироваться вне классов, вне зависимости от уровня доступа.

```cpp
#include <iostream>

class Something
{
private:
    static int s_value; 
public:
    static int get() {
        return s_value;
    }
};
 
int Something::s_value{ 1 }; 
 
int main()
{
    std::cout << Something::get() << '\n';
    return 0;
}
```


Один из популярных примеров использования **static**-переменных - счетчики объектов.

Рассмотрим класс **Object**:

```c++
class Object
{
private:
   ...
	static unsigned int count;
public:
	Object(Cell * = nullptr);
	~Object();
	char getName() const;
	static unsigned int getCount();
};
```

В конструкторе данного класса размещается операция инкремента счетчика, а в деструкторе - декремента. Запросив значение счетчика через метод **getCount**  мы можем узнать, какое количество объектов существует на данный момент:

```c++
cout << Object::getCount() << endl;
```
