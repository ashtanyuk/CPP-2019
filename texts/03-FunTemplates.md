## Обобщенное программирование

Одной из популярных современных парадигм программирования на C++ является **обобщенное программирование**, связанное с параметризацией типов. В любой, достаточно крупной задаче, неизбежно дублирование кода, реализующего некоторые алгоритмы и структуры данных. Дублирование возникает из-за разных типов обрабатываемых данных. То есть алгоритм один, а все отличие - в типах. Чтобы избежать дублирования используют **шаблоны**, с параметрами-типами.

В С++ существую *шаблоны функций*, *шаблоны классов* и *шаблоны переменных*. Далее, в первую очередь рассматриваются шаблоны функций.


## Шаблоны функций

Шаблон функций позволяет задать описание функции без привязки к конретным типам. В место них применяют типы-параметры.

```c++
template<typename T>
T square(T param)
{
   return param*param;
}
```

Данный шаблон описывает функцию возведения числа в квадрат. Описание данного шаблона нужно поместить в единице трансляции вместе с использованием (инстанцированием экземпляра функции).

Вызов шаблонной функции подразумевает автоматическое определение типа параметра:

```c++
int x=2;
cout<<square(x);
```

В момент обработки вызова, компилятор пытается инстанцировать функцию из шаблона с выведением типа Т. Нетрудно видеть, что данный вызов предполагает использование типа int.



### Пример шаблона

Наиболее известный пример: функция обмена значений двух переменных

```c++
template<class T>
void swap(T& a, T& b)
{
   T tmp;
   tmp=a;
   a=b;
   b=tmp;
}
```

Для получения функции проведем *инстанцирование*:

```c++
void fun() {
  int a=1, b=2;
  double c=1.1, d=2.2; 
  swap<int>(a,b);  // все в порядке
  swap(c,d);       // тоже все хорошо
  swap(a,d);       // ошибка, разные типы a и d!
}
```

### Передача ссылки на массив

Отдельный интерес вызывает случай, когда в функцию по ссылке передается массив.

Рассмотрим случай, когда ссылки нет:

```c++
#include <iostream>
using namespace std;

template<class T>
void fun(T arg)
{
    cout<<typeid(arg).name()<<endl;
}
int main()
{
    int arr[]{1,2,3};
    fun(arr);
    return 0;
}
```

В качестве ответа, выводимого на экран мы увидим **Pi**, то есть указатель на int.  Так происходит потому что при передаче имени массива без ссылочного параметра в функции мы получим указатель на первый элемент.

Рассмотрим случай с ссылкой:

```c++
#include <iostream>
using namespace std;

template<class T>
void fun(T & arg)
{
    cout<<typeid(arg).name()<<endl;
}

int main()
{
    int arr[]{1,2,3};
    fun(arr);
    return 0;
}
```

Теперь ответ другой: **Ai3**, то есть массив из трех целых. 

### Пример шаблона с целочисленным параметром

```c++
template< int BufferSize > // целочисленный параметр 
char* read()
{
   char *buffer = new char[ BufferSize ]; 
   return buffer;
}
...
char *ReadString = read< 20 >; 
delete [] ReadString; 
ReadString = read< 30 >;
...
```

### Параметры шаблона

В шаблонах допускается использование различных видов параметров

```c++
template
<class T1, // параметр-тип
 typename T2, // параметр-тип
 int I,   // параметр обычного типа
 T1 DefaultValue, // параметр обычного типа
 template< class > class T3,// параметр-шаблон
 class Character = char // параметр по умолчанию >
```

## Пример шаблона с параметров в виде шаблона

В следующем примере функция принимает стандартный контейнер из библиотеки STL и выводит его в выходной поток. Обратите внимание, что у шаблонного класса контейнера есть второй параметр - аллокатор.

```c++
template< template<typename, typename> class C, typename E >
void print(const C<E, allocator<E> >& v) {
  copy(v.begin(), v.end(), ostream_iterator<E>(cout, "  "));
  cout << endl;
}
```

## Передача функции в шаблонную функцию

Еще один важный пример: передача указателя на функцию в другую функцию. Все описано на шаблонах

```c++
#include<iostream>

template<typename E>
E square(E x)
{
   return x*x;
}

template<typename T>
void print(T x, T (*fun)(T))
{
   std::cout<<fun(x)<<std::endl;
}

int main()
{
   int x{5};
   print(x,square<int>);
   return 0;
}
```



## Вывод типов параметров шаблонов

В простейших случаях вывод нужного типа не вызывает проблем. Однако, могут встречаться и более сложные случае, особенно при использовании ссылочных типов.   


### Случай 1.  lvalue-ссылка

Ссылочная часть игнорируется

```c++
template<class T>
void printSquare(T& param)
{
   cout<<param*param;
}

int a=10;
const int b=a;
const int& c=a;
 
f(a); // T - int,       param - int&
f(b); // T - const int, param - const int& 
f(c); // T - const int, param - const int&
```

При добавление **const** в параметр:

```c++
template<class T>
void printSquare(const T& param)
{
   cout<<param*param;
}

int a=10;
const int b=a;
const int& c=a;
 
f(a); // T - int, param - const int&
f(b); // T - int, param - const int& 
f(c); // T - int, param - const int&
```

### Случай 2.  rvalue-ссылка

В этом случае надо смотреть, к какому типу выражений (lvalue или rvalue) принадлежит фактический параметр.

```c++
template<class T>
void printSquare(T&& param)
{
   cout<<param*param;
}

int a=10;
const int b=a;
const int& c=a;
 
f(a); // T - int&,       param - int&       (a - lvalue)
f(b); // T - const int&, param - const int& (b - lvalue)
f(c); // T - const int&, param - const int& (c - lvalue)
f(10);// T - int,        param - int&&      (27 - rvalue)
```


### Перегрузка шаблонов

```c++
template<class T> T sqrt(T);
template<class T> complex<T> sqrt(complex<T>); 
double sqrt(double);

void fun(complex<double> z) {
  sqrt(2);   // sqrt<int> (int)
  sqrt(2.0); // sqrt(double)
  sqrt(z);   // sqrt <double> (complex<double>)
}
```

Для каждого шаблона осуществляется поиск специализации, наилучшим образом соответствующий списку аргументов. Затем применяются обычные правила разрешения перегрузки применительно к этим специализациям и обычным функциям.

- ищется набор специализаций шаблонов функций, которые примут участие в разрешении перегрузки. Это осуществляется с учетом всех шаблонов функции. Принимается решение, какие аргументы функции были бы использованы (если вообще были бы), если бы в текущей области видимости не было других шаблонов функций и обычных функций с тем же именем. В примере с вызовом **sqrt(z)** к рассмотрению будут приняты **sqrt<double>(complex<double>)** и **sqrt<complex <double>>(complex <double>)**.
   
- если могут быть вызваны два шаблона функции, и один из них более специализирован, чем другой, на следующих этапах только он и рассматривается. В примере с вызовом **sqrt(z)**, это означает, что предпочтение отдается **sqrt<double>(complex <double>)** по отношению к **sqrt<complex<double>>(complex
<double>)**: любой вызов, который соответствует **sqrt<T>(complex T)**, так же
соответствует и **sqrt<T>(T)**.
   
- разрешается перегрузка для этого набора функций, а также для любых обычных функций (для них перегрузка разрешается как для обычных функций). Если аргументы функции шаблона были определены путем выведения по фактическим аргументам шаблона, к ним нельзя применять «продвижение», стандартные и определяемые пользователем преобразования. Для **sqrt(2)** **sqrt<int>(int)** является точным соответствием и поэтому ей отдается предпочтение по отношению к **sqrt(double)**.
   
- если и обычная функция и специализация подходят одинаково хорошо, отдается предпочтение обычной функции. Следовательно, для **sqrt(2.0)** выбирается **sqrt(double)**, а не **sqrt<double>(double)**.

- если ни одного соответствия не найдено, вызов считается ошибочным. Если процесс заканчивается с двумя или более одинаково хорошо подходящими вариантами, вызов является неоднозначным и это тоже ошибка.

### Специализация шаблонов

По своему назначению, шаблоны подходят к использованию со множеством типов. Но иногда нужно определить версию шаблона для конкретного типа. Это называется **специализация**:

```c++
template<class T> bool less(T a, T b) 
{
   return a < b; 
}
template<> bool less<const char*>(const char* a, const char* b)
{
   return strcmp(a, b) < 0;
}
```

Для числовых типов можно использовать операцию "меньше", а для строк С - вызов библиотечной функции.

Еще пример специализации:

```c++
#include <iostream>
using namespace std;
template<typename T> T func(T t) {
    cout << "func" << endl;
};
template<typename T> T * func(T *t) {
    cout << "func with pointer!" << endl;
};
int main() {
    func(2);
    int i = 2;
    func(&i);
}
```

### Шаблоны и рекурсия

Необычными свойствами обладает использование рекурсии при работе с шаблонами

```c++
#include <iostream>
using namespace std;
template <int i> int func() {
    return func<i-1>()+i;
};
template <> int func<0>() {
    return 0;
};
int main () {
   cout << func<12>() << endl;
   return 0;
};
```

Рекурсия в случае с шаблонами используется во время построения программы, а не во время ее выполнения. Это дает возможность вычислить значение функции еще до того, как она будет запущена и мгновенно выдать ответ. Расплатой за такую возможность является более длительное время компиляции.

Кстати, при попытке выбрать большое значение для **func** выдается следующая ошибка:

```c++
fatal error: recursive template instantiation
      exceeded maximum depth of 256
    return func<i-1>()+i;
```

Для обхода этого ограничения служит специальная опция компилятора:

```
g++ tmpl1.cpp -ftemplate-depth=2000
```

Еще пример использования рекурсии в шаблонах:

```c++
template<int n>
struct Fact {
   enum { RET = n * Fact<n-1>::RET };
};
template<>
struct Fact<1> {
  enum { RET = 1 };
};
int b = Fact<5>::RET; // == 120
```

Возведение числа в степень:

```c++
template<int n>
inline int Power(const int x){
   return Power<n-1>(x) * x;
}
template<>
inline int Power<1>(const int x){
  return 1; 
}
template<>
inline int Power<0>(const int x){
   return 1; 
}
cout <_< Power<4>(m);
```

Пример для определения максимального числа:

```c++
template<int n1, int n2>
struct Max {
  enum { RET = (n1 > n2) ? n1 : n2 };
};
cout <_< Max<42, 6>::RET; //prints 42
```



### Вариативные шаблоны

В стандарте С++11 определены **вариативные шаблоны** с переменным количеством параметров.

```c++
#include <iostream>
using namespace std;

double sum(double x)
{
    return x;
}

template<class... Args>
double sum(double x, Args... args)
{
    return x+sum(args...);
}

int main()
{
    cout<<sum(1,2,3,4,5,6,7,8,9,10)<<endl;
    return 0;
}
```

Они дают возможность создавать функции с переменным числом аргументов.

### Специализация шаблонов и перегрузка

см. [статья](https://habr.com/post/237323/)

Рассмотрим пример:

```c++
#include <iostream>
using namespace std;

/////////////////////////////////////////////
template<typename T> void foo(T)   // 1
{
   cout<<"foo(T)"<<endl;
}
template<> void foo(int*)          // 2
{
   cout<<"foo(int*)"<<endl;
}
template<typename T> void foo(T*)  // 3
{
   cout<<"foo(T*)"<<endl;
}
/////////////////////////////////////////////
template<typename T> void bar(T)   // 4
{
   cout<<"bar(T)"<<endl;
}
template<typename T> void bar(T*)  // 5
{
   cout<<"bar(T*)"<<endl;
}
template<> void bar(int*)          // 6
{
   cout<<"bar(int*)"<<endl;
}

int main()
{
    int i;
    foo(&i);
    bar(&i);
    return 0;
}
```

Необходимо определить, какие версии шаблона будет использовать компилятор.

Ответ:

```c++
foo(T*)
bar(int*)
```


Сначала выбирается лучший кандидат среди обычных функций и шаблонов, причем предпочтение отдается обычным функциям. Если же более подходящим является шаблон, то проверяется а нет ли у него еще более подходящих специализаций и, если есть, выбирается одна из них.

Тонкий момент заключается в том, что для того чтобы специализация шаблонной функции считалась таковой, шаблон должен быть объявлен в коде перед этой специализацией.

То есть в примере выше (2) является специализацией не (3) а (1), поэтому для перегрузки будет выбран более подходящий базовый шаблон (3). Во втором же случае (6) является специализацией (5), которая в свою очередь является лучшей кандидатурой, чем (4).

**Упражнение**
> Переставьте местами описания функций 2 и 3 и проверьте результат. Попробуйте также изменить порядок следования функций 4-6.

### Шаблоны переменных

Эта возможность появилась в С++14. Ее применение иллюстрирует следующий пример:

```c++
template<class T>
constexpr T pi = T(3.1415926535897932385L);

template<class T>
T circular_area(T r) {
  return pi<T> * r * r;
}
```
